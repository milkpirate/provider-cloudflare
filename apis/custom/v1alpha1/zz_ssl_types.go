// SPDX-FileCopyrightText: 2023 The Crossplane Authors <https://crossplane.io>
//
// SPDX-License-Identifier: Apache-2.0

/*
Copyright 2022 Upbound Inc.
*/

// Code generated by upjet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type CustomSSLOptionsInitParameters struct {

	// (String) Method of building intermediate certificate chain. A ubiquitous bundle has the highest probability of being verified everywhere, even by clients using outdated or unusual trust stores. An optimal bundle uses the shortest chain and newest intermediates. And the force bundle verifies the chain, but does not otherwise modify it. Available values: ubiquitous, optimal, force.
	// Method of building intermediate certificate chain. A ubiquitous bundle has the highest probability of being verified everywhere, even by clients using outdated or unusual trust stores. An optimal bundle uses the shortest chain and newest intermediates. And the force bundle verifies the chain, but does not otherwise modify it. Available values: `ubiquitous`, `optimal`, `force`.
	BundleMethod *string `json:"bundleMethod,omitempty" tf:"bundle_method,omitempty"`

	// (String) Certificate certificate and the intermediate(s).
	// Certificate certificate and the intermediate(s).
	Certificate *string `json:"certificate,omitempty" tf:"certificate,omitempty"`

	// (String) Specifies the region where your private key can be held locally. Available values: us, eu, highest_security.
	// Specifies the region where your private key can be held locally. Available values: `us`, `eu`, `highest_security`.
	GeoRestrictions *string `json:"geoRestrictions,omitempty" tf:"geo_restrictions,omitempty"`

	// (String) Whether to enable support for legacy clients which do not include SNI in the TLS handshake. Available values: legacy_custom, sni_custom.
	// Whether to enable support for legacy clients which do not include SNI in the TLS handshake. Available values: `legacy_custom`, `sni_custom`.
	Type *string `json:"type,omitempty" tf:"type,omitempty"`
}

type CustomSSLOptionsObservation struct {

	// (String) Method of building intermediate certificate chain. A ubiquitous bundle has the highest probability of being verified everywhere, even by clients using outdated or unusual trust stores. An optimal bundle uses the shortest chain and newest intermediates. And the force bundle verifies the chain, but does not otherwise modify it. Available values: ubiquitous, optimal, force.
	// Method of building intermediate certificate chain. A ubiquitous bundle has the highest probability of being verified everywhere, even by clients using outdated or unusual trust stores. An optimal bundle uses the shortest chain and newest intermediates. And the force bundle verifies the chain, but does not otherwise modify it. Available values: `ubiquitous`, `optimal`, `force`.
	BundleMethod *string `json:"bundleMethod,omitempty" tf:"bundle_method,omitempty"`

	// (String) Certificate certificate and the intermediate(s).
	// Certificate certificate and the intermediate(s).
	Certificate *string `json:"certificate,omitempty" tf:"certificate,omitempty"`

	// (String) Specifies the region where your private key can be held locally. Available values: us, eu, highest_security.
	// Specifies the region where your private key can be held locally. Available values: `us`, `eu`, `highest_security`.
	GeoRestrictions *string `json:"geoRestrictions,omitempty" tf:"geo_restrictions,omitempty"`

	// (String) Whether to enable support for legacy clients which do not include SNI in the TLS handshake. Available values: legacy_custom, sni_custom.
	// Whether to enable support for legacy clients which do not include SNI in the TLS handshake. Available values: `legacy_custom`, `sni_custom`.
	Type *string `json:"type,omitempty" tf:"type,omitempty"`
}

type CustomSSLOptionsParameters struct {

	// (String) Method of building intermediate certificate chain. A ubiquitous bundle has the highest probability of being verified everywhere, even by clients using outdated or unusual trust stores. An optimal bundle uses the shortest chain and newest intermediates. And the force bundle verifies the chain, but does not otherwise modify it. Available values: ubiquitous, optimal, force.
	// Method of building intermediate certificate chain. A ubiquitous bundle has the highest probability of being verified everywhere, even by clients using outdated or unusual trust stores. An optimal bundle uses the shortest chain and newest intermediates. And the force bundle verifies the chain, but does not otherwise modify it. Available values: `ubiquitous`, `optimal`, `force`.
	// +kubebuilder:validation:Optional
	BundleMethod *string `json:"bundleMethod,omitempty" tf:"bundle_method,omitempty"`

	// (String) Certificate certificate and the intermediate(s).
	// Certificate certificate and the intermediate(s).
	// +kubebuilder:validation:Optional
	Certificate *string `json:"certificate,omitempty" tf:"certificate,omitempty"`

	// (String) Specifies the region where your private key can be held locally. Available values: us, eu, highest_security.
	// Specifies the region where your private key can be held locally. Available values: `us`, `eu`, `highest_security`.
	// +kubebuilder:validation:Optional
	GeoRestrictions *string `json:"geoRestrictions,omitempty" tf:"geo_restrictions,omitempty"`

	// (String, Sensitive) Certificate's private key.
	// Certificate's private key.
	// +kubebuilder:validation:Optional
	PrivateKeySecretRef *v1.SecretKeySelector `json:"privateKeySecretRef,omitempty" tf:"-"`

	// (String) Whether to enable support for legacy clients which do not include SNI in the TLS handshake. Available values: legacy_custom, sni_custom.
	// Whether to enable support for legacy clients which do not include SNI in the TLS handshake. Available values: `legacy_custom`, `sni_custom`.
	// +kubebuilder:validation:Optional
	Type *string `json:"type,omitempty" tf:"type,omitempty"`
}

type CustomSSLPriorityInitParameters struct {

	// (String) The ID of this resource.
	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	// (Number)
	Priority *float64 `json:"priority,omitempty" tf:"priority,omitempty"`
}

type CustomSSLPriorityObservation struct {

	// (String) The ID of this resource.
	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	// (Number)
	Priority *float64 `json:"priority,omitempty" tf:"priority,omitempty"`
}

type CustomSSLPriorityParameters struct {

	// (String) The ID of this resource.
	// +kubebuilder:validation:Optional
	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	// (Number)
	// +kubebuilder:validation:Optional
	Priority *float64 `json:"priority,omitempty" tf:"priority,omitempty"`
}

type SSLInitParameters struct {

	// (Block List, Max: 1) The certificate associated parameters. Modifying this attribute will force creation of a new resource. (see below for nested schema)
	// The certificate associated parameters. **Modifying this attribute will force creation of a new resource.**
	CustomSSLOptions []CustomSSLOptionsInitParameters `json:"customSslOptions,omitempty" tf:"custom_ssl_options,omitempty"`

	// (Block List) (see below for nested schema)
	CustomSSLPriority []CustomSSLPriorityInitParameters `json:"customSslPriority,omitempty" tf:"custom_ssl_priority,omitempty"`
}

type SSLObservation struct {

	// (Block List, Max: 1) The certificate associated parameters. Modifying this attribute will force creation of a new resource. (see below for nested schema)
	// The certificate associated parameters. **Modifying this attribute will force creation of a new resource.**
	CustomSSLOptions []CustomSSLOptionsObservation `json:"customSslOptions,omitempty" tf:"custom_ssl_options,omitempty"`

	// (Block List) (see below for nested schema)
	CustomSSLPriority []CustomSSLPriorityObservation `json:"customSslPriority,omitempty" tf:"custom_ssl_priority,omitempty"`

	// (String)
	ExpiresOn *string `json:"expiresOn,omitempty" tf:"expires_on,omitempty"`

	// (List of String)
	Hosts []*string `json:"hosts,omitempty" tf:"hosts,omitempty"`

	// (String) The ID of this resource.
	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	// (String)
	Issuer *string `json:"issuer,omitempty" tf:"issuer,omitempty"`

	// (String)
	ModifiedOn *string `json:"modifiedOn,omitempty" tf:"modified_on,omitempty"`

	// (Number)
	Priority *float64 `json:"priority,omitempty" tf:"priority,omitempty"`

	// (String)
	Signature *string `json:"signature,omitempty" tf:"signature,omitempty"`

	// (String)
	Status *string `json:"status,omitempty" tf:"status,omitempty"`

	// (String)
	UploadedOn *string `json:"uploadedOn,omitempty" tf:"uploaded_on,omitempty"`

	// (String) The zone identifier to target for the resource.
	// The zone identifier to target for the resource.
	ZoneID *string `json:"zoneId,omitempty" tf:"zone_id,omitempty"`
}

type SSLParameters struct {

	// (Block List, Max: 1) The certificate associated parameters. Modifying this attribute will force creation of a new resource. (see below for nested schema)
	// The certificate associated parameters. **Modifying this attribute will force creation of a new resource.**
	// +kubebuilder:validation:Optional
	CustomSSLOptions []CustomSSLOptionsParameters `json:"customSslOptions,omitempty" tf:"custom_ssl_options,omitempty"`

	// (Block List) (see below for nested schema)
	// +kubebuilder:validation:Optional
	CustomSSLPriority []CustomSSLPriorityParameters `json:"customSslPriority,omitempty" tf:"custom_ssl_priority,omitempty"`

	// (String) The zone identifier to target for the resource.
	// The zone identifier to target for the resource.
	// +crossplane:generate:reference:type=github.com/milkpirate/provider-cloudflare/apis/zone/v1alpha1.Zone
	// +kubebuilder:validation:Optional
	ZoneID *string `json:"zoneId,omitempty" tf:"zone_id,omitempty"`

	// Reference to a Zone in zone to populate zoneId.
	// +kubebuilder:validation:Optional
	ZoneIDRef *v1.Reference `json:"zoneIdRef,omitempty" tf:"-"`

	// Selector for a Zone in zone to populate zoneId.
	// +kubebuilder:validation:Optional
	ZoneIDSelector *v1.Selector `json:"zoneIdSelector,omitempty" tf:"-"`
}

// SSLSpec defines the desired state of SSL
type SSLSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     SSLParameters `json:"forProvider"`
	// THIS IS A BETA FIELD. It will be honored
	// unless the Management Policies feature flag is disabled.
	// InitProvider holds the same fields as ForProvider, with the exception
	// of Identifier and other resource reference fields. The fields that are
	// in InitProvider are merged into ForProvider when the resource is created.
	// The same fields are also added to the terraform ignore_changes hook, to
	// avoid updating them after creation. This is useful for fields that are
	// required on creation, but we do not desire to update them after creation,
	// for example because of an external controller is managing them, like an
	// autoscaler.
	InitProvider SSLInitParameters `json:"initProvider,omitempty"`
}

// SSLStatus defines the observed state of SSL.
type SSLStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        SSLObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true

// SSL is the Schema for the SSLs API. Provides a Cloudflare custom SSL resource.
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,cloudflare}
type SSL struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              SSLSpec   `json:"spec"`
	Status            SSLStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// SSLList contains a list of SSLs
type SSLList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []SSL `json:"items"`
}

// Repository type metadata.
var (
	SSL_Kind             = "SSL"
	SSL_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: SSL_Kind}.String()
	SSL_KindAPIVersion   = SSL_Kind + "." + CRDGroupVersion.String()
	SSL_GroupVersionKind = CRDGroupVersion.WithKind(SSL_Kind)
)

func init() {
	SchemeBuilder.Register(&SSL{}, &SSLList{})
}
